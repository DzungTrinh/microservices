// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: credential.sql

package mysql

import (
	"context"
)

const createCredential = `-- name: CreateCredential :exec
INSERT INTO credentials (id, user_id, provider, secret_hash, provider_uid, created_at)
VALUES (?, ?, ?, ?, ?, NOW())
`

type CreateCredentialParams struct {
	ID          string `json:"id"`
	UserID      string `json:"user_id"`
	Provider    string `json:"provider"`
	SecretHash  string `json:"secret_hash"`
	ProviderUid string `json:"provider_uid"`
}

func (q *Queries) CreateCredential(ctx context.Context, arg CreateCredentialParams) error {
	_, err := q.db.ExecContext(ctx, createCredential,
		arg.ID,
		arg.UserID,
		arg.Provider,
		arg.SecretHash,
		arg.ProviderUid,
	)
	return err
}

const getCredentialByEmailAndProvider = `-- name: GetCredentialByEmailAndProvider :one
SELECT id, user_id, provider, secret_hash, provider_uid, created_at, COALESCE(deleted_at, TIMESTAMP '0001-01-01 00:00:00') AS deleted_at
FROM credentials
WHERE user_id = (SELECT id FROM users WHERE email = ? AND deleted_at IS NULL) AND provider = ? AND deleted_at IS NULL
`

type GetCredentialByEmailAndProviderParams struct {
	Email    string `json:"email"`
	Provider string `json:"provider"`
}

func (q *Queries) GetCredentialByEmailAndProvider(ctx context.Context, arg GetCredentialByEmailAndProviderParams) (Credential, error) {
	row := q.db.QueryRowContext(ctx, getCredentialByEmailAndProvider, arg.Email, arg.Provider)
	var i Credential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.SecretHash,
		&i.ProviderUid,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}
